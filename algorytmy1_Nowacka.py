# -*- coding: utf-8 -*-
"""algorytmy1

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1-cAIJMga6c_zXqz4m_MpALyULvB_nqv3
"""

#zadanie 1
import random, time, numpy as np
import matplotlib.pyplot as plt
from scipy.optimize import curve_fit
x=5
#1.1
def wielomian(n):
    a=[]
    for i in range(0,n+1):
        a.append(random.randint(-20, 20))
    return a

def oblx(x,n):
    a=wielomian(n)
    start=time.time()
    p=0
    for i in range(0,n+1):
        p+=a[i]*x**i
    end=time.time()
    return p, end-start

xs = [3,10,50,70,100,150,200,250,300,400,500]
ys = []

# złożoność wynika z potęgowania x*x*...*x - n razy

# zadanie 1.2
import math
def pot(x,n):
  if n==0:
    return 1
  if n%2==1:
    return x*(pot(x,(n-1)/2))**2
  return (pot(x,n/2))**2

def oblx2(x,n):
    a=wielomian(n)
    start=time.time()
    p=0
    for i in range(0,n+1):
        p+=a[i]*pot(x,i)
    end=time.time()
    return p, end-start

xs=[3,10,50,100,200,400,600,1000]
ys=[]
for i in xs:
  ys.append(oblx2(x,i)[1])

# złożoność n * logn (dzielenie na kilka mniejszych operacji np. x^2 * x^2 zamiast x*x*x*x )

#1.3
#O(n)

def horner(x,n):
  a=wielomian(n)
  p=0
  tab = []
  tab.append(a[n])
  for i in range (1,n+1):
    tab.append(tab[i-1]*x+a[n-i])
  p = tab[-1]
  return a,p

horner(2,5)

# złożoność O(n) wynika z 1 pętli

# zadanie 2
def example1(S):
    """Return the sum of the elements in sequence S."""
    start=time.time()
    n = len(S)
    total = 0
    for j in range(n):
        total += S[j]
    end=time.time()
    return total, end-start

def func(x, a, b):
  return a*x + b

xs=list(range(100,10000,1000))
ys=[]
for i in xs:
  ys.append(example1(np.zeros(i))[1])
print(xs)
popt, pcov = curve_fit(func, xs, ys)
x2 = np.array(xs)
plt.plot(xs,ys,'ro',label="Dane")
plt.plot(x2, func(x2, *popt), label="Hipoteza")
plt.xlabel("Rozmiar")
plt.ylabel("Czas wykonania")
plt.legend(loc='upper left')
plt.title("Example 1")
plt.show()
print(popt[0],popt[1])

def example2(S):
    """Return the sum of the elements with even index in sequence S."""
    start=time.time()
    n = len(S)
    total = 0
    for j in range(0, n, 2):
        total += S[j]
    end=time.time()
    return total, end-start

def func(x, a, b):
  return a*x + b

xs=[1,10,100,500,1000,1500]
ys=[]
for i in xs:
  ys.append(example2(np.zeros(i))[1])

popt, pcov = curve_fit(func, xs, ys)
x2 = np.arange(1,2000)
plt.plot(xs,ys,'ro',label="Dane")
plt.plot(x2, func(x2, *popt), label="Hipoteza")
plt.xlabel("Rozmiar")
plt.ylabel("Czas wykonania")
plt.legend(loc='upper left')
plt.title("Example 2")
plt.show()
print(popt[0],popt[1])

def example3(S):
    """Return the sum of the prex sums of sequence S."""
    start=time.time()
    n = len(S)
    total = 0
    for j in range(n):
        for k in range(1+j):
            total += S[k]
    end=time.time()
    return total, end-start
def func(x, a, b,c):
  return a*x**2 + b*x +c

xs=[1,10,100,500,1000,1500,2000,4000]
ys=[]
for i in xs:
  ys.append(example3(np.zeros(i))[1])

popt, pcov = curve_fit(func, xs, ys)
x2 = np.arange(1,4000)
plt.plot(xs,ys,'ro',label="Dane")
plt.plot(x2, func(x2, *popt), label="Hipoteza")
plt.xlabel("Rozmiar")
plt.ylabel("Czas wykonania")
plt.legend(loc='upper left')
plt.title("Example 3")
plt.show()
print(popt[0],popt[1],popt[2])

def example4(A, B): # assume that A and B have equal length
    """Return the number of elements in B equal to the sum of prex
    sums in A."""
    start=time.time()
    n = len(A)
    count = 0
    for i in range(n):
        total = 0
        for j in range(n):
            for k in range(1+j):
                total += A[k]
        if B[i] == total:
            count += 1
    end=time.time()
    return count, end-start

def func(x, a, b, c, d):
  return a*x**3 + b*x**2 + c*x +d

xs=[1,10,50,100,200,500,1000]
ys=[]
for i in xs:
  ys.append(example4(np.zeros(i),np.zeros(i))[1])

popt, pcov = curve_fit(func, xs, ys)
x2 = np.arange(1,2000)
plt.plot(xs,ys,'ro',label="Dane")
plt.plot(x2, func(x2, *popt), label="Hipoteza")
plt.xlabel("Rozmiar")
plt.ylabel("Czas wykonania")
plt.legend(loc='upper left')
plt.title("Example 4")
plt.show()
print(popt[0],popt[1], popt[2])

# zadanie 3
import random
import numpy as np
xs = [3,10,50,100,300,1000,1500,2000]
ys = []
def czas(n):
  tab=[]
  for i in range(n):
    tab.append(random.randint(0,1000))
  start=time.time()
  s = sorted(tab)
  end=time.time()
  return s, end-start

for i in xs:
  ys.append(czas(i)[1])

def func(x, a, b):
  return a*x*np.log(x) + b

popt, pcov = curve_fit(func, xs, ys)
x2 = np.arange(1,2000)
plt.plot(xs,ys,'ro',label="Dane")
plt.plot(x2, func(x2, *popt), label="Hipoteza")
plt.xlabel("Rozmiar")
plt.ylabel("Czas wykonania")
plt.legend(loc='upper left')
plt.title("Sortowanie")
plt.show()
print(popt[0],popt[1])
